四.运算符优先级
1.圆括号（）
2.自增运算符++，自减运算符--
3.单目运算符 + 和 - 
4.乘法 *，除法 / 
5.加法+，减法-
6.关系运算符 <，>等
7.赋值运算符 = 

五.其余操作符
1.取模 %
（1）负数取模规则：取模只看第一个操作数的符号，得到的模与第一个操作数的符号相同
2.按位取反操作符 ~
（1）功能：二进制0、1互相转换
3.逗号表达式
（1）规则：从左向右依次执行。整个表达式的结果是最后一个表达式的结果
while(a=get_val(),count_val(a),a>0)
{
    ;//
}
或者
do
{
    a=get_val(),count_val(a);
}while(a>0)
4.函数调用操作符 ()
（1）特点：至少有一个操作数，即自身
5.sizeof()
（1）sizeof不是函数，是操作符。证明如下
int a=10;
int ret=sizeof a;

六.表达式求值
1.特点：表达式求值前要进行类型转换，当表达式中的值转换到适当的类型，才开始计算。类型转换后可能发生数据截断，截断后存储
2.过程：
整型提升：
（1）C语言中整型算术运算总是至少以缺省整型类型（int）的精度来进行的。为了获得这个精度，表达式中的字符（char）和短整型（short）操作数在使用之前被转换位普通整型，这种转换成为整型提升。
- 有符号整数：按照变量的数据类型的符号位来提升
- 无符号整数：高位补0
（2）算术转换：
功能：如果某个操作符的各个操作数属于不同类型，必须将一个操作数转换为另一个操作数的类型，否则操作无法进行

3.代码示例：
#include <stdio.h>

int main() {
    unsigned char a = 250;
    signed char b = -10;
    // a 和 b 先进行整型提升为 int 类型，然后 b 再根据规则转换为无符号类型参与运算
    unsigned int result = a + b; 
    printf("Result: %u\n", result);
    return 0;
}
4.问题代码：
1.
a*b+c*d+e*f
注意：操作符的优先级和结合性只适用于相邻数据,因此无法确定表达式的唯一计算路径

2.
c+ --c
注意：无法确定左边的c是在什么时候读取数据的

3.
int fun()
{
    static int count=1;
    return ++count;
}
int main()
{
    int answer;
    answer=fun()-fun()*fun();
    printf("%d\n",answer);
    return 0;
}
注意：操作符的优先级和结合性无法决定哪个fun()函数先调用
