一.自定义类型
1.结构体
2.枚举
3.联合体

二.结构体的声明和定义
1.
//结构体声明，不开辟内存
struct Stu
{
    //结构体成员变量的声明
    char name[20];
    int age;
}s4={"zhangsan",18},s5;//全局变量
int main()
{
    //结构体(变量)定义，创建具体的结构体变量
    struct Stu s1,s2;//局部变量
    //仅在C中可运行，可不按照变量的声明顺序进行初始化，且可重复并取最后一个的数据
    struct Stu s3={.age=18,  .name="lisi"，.age=20};//age=20
    //在C++中可运行，C++20才支持。必须按照变量的声明顺序进行初始化
    struct Stu s6={.name="wangwu", .age=30};
}
2.结构体的特殊声明
//匿名结构体类型
struct
{
    int a;
    char b;
}x,a[20];
struct
{
    int a;
    char b;
}*p;
p=&x;//非法，编译器会将上面两个声明当成两个不同的类型
3.使用typedef的格式
typedef struct Node
{
    int data;
    struct Node* next;
}Node;
三.结构体内存对齐 
1.对齐规则
（1）除第一个成员，其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
对齐数 = 编译器默认的一个对齐数 与 该成员变量大小的较小值
VS默认为8，
Linux没有默认对齐数，对齐数就是成员自身的大小
//编译器 的默认对齐数可修改
#pragma pack(1) //设置默认对齐数为1
#pragma pack() //还原为默认
（2）结构体总大小为最大对齐数（结构体中的成员的最大对齐数）的整数倍
（3）如果嵌套了结构体，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍，结构体的大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍
offsetof(struct 结构体名,成员1);//宏 - 用来计算结构体成员，相较于起始位置的偏移量

2.为什么存在内存对齐
1.平台原因：某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
2.性能原因：数据结构（尤其是栈）应尽可能地在自然边界上对齐。原因在于，为了访问未对其的内存，处理器需要作两次内存访问；而对齐地内存访问仅需一次。总体来说：结构体内存对齐是拿空间换时间地做法

四.结构体传参
优选：传址调用
原因：
（1）函数传参的适合，参数需要压栈，会有时间和空间上的系统开销
（2）在传递结构体对象时，结构体过大，参数压栈的系统开销比较大，导致性能下降
结论：
（1）结构体传参的时候，要传结构体的地址
