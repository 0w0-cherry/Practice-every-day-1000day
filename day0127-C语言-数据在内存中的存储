一.什么是大小端
1.大端（存储）模式：是指数据低位字节内容保存在内存的高地址处
2.小端（存储）模式：是指数据的低位字节内容保存在内存的低地址处

二.判断大小端
1.通过移位操作
地址：高地址------------->低地址
小端模式存放：00 00 00 01>>1 == 00 00 00 00
大端模式存放：10 00 00 00>>1 == 01 00 00 00

2.通过联合体判断
int storage_mode()
{
    union
    {
        char a;
        int b;    
    }u;
    u.b=1;
    return a;
}
3.通过强制类型转换判断
int storage_mode()
{
    int i=1;
    return *(char*)&i;
}
三.对char类型的判断
1.char类型比较特殊，signed char还是unsigned char是不确定的，取决于编译器（VS上char==signed char）


四.浮点数在内存中的存储
1.二进制浮点数V的表示


V=5.5
 =101.1 //二进制
 =1.011*2^2
 =(-1)^0 * 1.011 * 2^2
 
S=0
M=1.011
E=2
2.内存分配
（1）float
对于32位的浮点数，最⾼的1位存储符号位S，接着的8位存储指数E，剩下的23位存储有效数字M


（2）double
对于64位的浮点数，最⾼的1位存储符号位S，接着的11位存储指数E，剩下的52位存储有效数字M


3.对于指数E的特别规定
（1）E有可能为负数，但E是被当作无符号数进行处理
因此E在存入内存时必须加上中间数
对于8位的E，中间数是127
对于11位的E，中间数是1023
//E为负数
V=0.5
 =0.1 //二进制
 =1.0*2^-1
 =(-1)^0 * 1.0 * 2^-1
 
S=0
M=1.0
E=-1（对于8位E，需要加上127）
（2）E为全0
此时指数E=1-127（或者1-1023）由于数字太小，有效数字M不再加上1，而是变为0.xxxxx的小数。这样做表示接近0的很小的数字

（3）E为全1
这时，有效数字M全为0，表示+-无穷大（正负号取决于s）
4.对于有效数字M的特别规定
（1）1<=M<2,因此M可以写成1.xxxxxx的形式，其中xxxxx表示小数部分
（2）在计算机保存M时，这个数的第一位总是1，因此可被省去，只保存小数部分。（如1.01，只保存01,在读取时把前面的1加上）目的是为了节省1位有效数字，提高精度
