
//最大数组和
https://leetcode.cn/problems/maximum-subarray/
//问题：该方法时间复杂度为O（N*N），超出时间限制
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> dp(n);
        //无法处理数组为全负数,数组最大和为0可处理
        for(int i=0;i<n;i++)
        {
            dp[i]=0;
            for(int j=0;j<=i;j++)
            {
                dp[i]=max(0,dp[i]+nums[j]);
            }
        }

        int Max=dp[0];
        for(int i=1;i<n;i++)
        {
            Max=max(Max,dp[i]);
        }
        //处理数组最大和为负数
        if(Max==0)//Max为0说明数组最大和为0或者数组为全负数，因此数组最大和为nums数组中的某个单个元素
        {
            Max=nums[0];
            for(int i=1;i<n;i++)
            {
                Max=max(Max,nums[i]);
            }
        }
        return Max;
    }
};
//优化，时间复杂度O（N）
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> dp(n);
        dp[0]=nums[0];
        for(int i=1;i<n;i++)
        {
            dp[i]=max(0,dp[i-1])+nums[i];
        }
        int Max=dp[0];
        for(int i=1;i<n;i++)
        {
            Max=max(Max,dp[i]);
        }
        return Max;
    }
};

https://leetcode.cn/problems/JEj789/
//粉刷房子
class Solution {
public:
    int minCost(vector<vector<int>>& costs) {
        int n=costs.size();
        vector<int> f(n+1);
        auto g=f;
        auto k=f;

        //f[0]=costs[0][0];//0号,红
        //g[0]=costs[0][1];//蓝
        //k[0]=costs[0][2];//绿
        for(int i=1;i<=n;i++)
        {
            f[i]=min(g[i-1],k[i-1])+costs[i-1][0];
            g[i]=min(f[i-1],k[i-1])+costs[i-1][1];
            k[i]=min(f[i-1],g[i-1])+costs[i-1][2];
        }
        return min(min(f[n],g[n]),k[n]);
    }
};
